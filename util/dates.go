package util

import (
	"sync/atomic"
	"time"
	"unicode"
)

// ctime-no-ms
// Wed Dec 31 19:00:00

// ctme
// Wed Dec 31 19:00:00.000

// iso8601-utc
// 1970-01-01T00:00:00.000Z

// iso8601-local
// 1969-12-31T19:00:00.000+0500

// Some arbitrary length that is enforced before parsing date strings. In this case, a value of 10 includes the day,
// month, and two number date as a minimum. The time could, theoretically, be included in the minimum but it will all
// come out in the wash later.
const (
	DATE_FORMAT_CTIMENOMS     = DateFormat("Mon Jan _2 15:04:05")
	DATE_FORMAT_CTIME         = DateFormat("Mon Jan _2 15:04:05.000")
	DATE_FORMAT_CTIMEYEAR     = DateFormat("Mon Jan _2 2006 15:04:05.000")
	DATE_FORMAT_ISO8602_UTC   = DateFormat("2006-01-02T15:04:05.000Z")
	DATE_FORMAT_ISO8602_LOCAL = DateFormat("2006-01-02T15:04:05.000-0700")
)

type DateFormat string

type DateParser struct {
	order []DateFormat
	pos   int64
}

var DefaultDateParser = DateParser{
	order: []DateFormat{DATE_FORMAT_CTIME, DATE_FORMAT_CTIMENOMS, DATE_FORMAT_CTIMEYEAR, DATE_FORMAT_ISO8602_UTC, DATE_FORMAT_ISO8602_LOCAL},
}

// These dates are sorted for binary searching.
var DATE_DAYS = []string{"Fri", "Mon", "Sat", "Sun", "Thu", "Tue", "Wed"}
var DATE_MONTHS = []string{"Apr", "Aug", "Dec", "Feb", "Jan", "Jul", "Jun", "Mar", "May", "Nov", "Oct", "Sep"}
var DATE_YEAR = time.Now().Year()

// Create a new date parser object based on an array of date formats.
func NewDateParser(formats []DateFormat) *DateParser {
	return &DateParser{order: formats}
}

// Clone a DateParser object, returning a new reference. Please note: the order
// slice is not copied (but is also not modified).
func (d DateParser) Clone() *DateParser {
	r := &DateParser{
		order: d.order,
		pos:   0,
	}
	return r
}

// Parse string _value_ into a time.Time object. The parser always tries the
// most recent success first (atomically).
func (d *DateParser) Parse(value string) (time.Time, DateFormat, error) {
	var (
		date   time.Time
		err    error
		index  int
		picked DateFormat
	)

	pos := int(atomic.LoadInt64(&d.pos))

	for index = 0; index < len(d.order); index += 1 {
		offset := (pos + index) % len(d.order)

		if date, err = time.Parse(string(d.order[offset]), value); err == nil {
			picked = d.order[offset]

			if index > 0 {
				atomic.StoreInt64(&d.pos, int64(offset))
			}

			break
		}
	}

	return date, picked, err
}

func IsDay(match string) bool {
	return ArrayBinaryMatchString(match, DATE_DAYS)
}

// Takes string and returns if the string *looks* like an ISO formatted date,
// specifically the format generated by MongoDB (YYYY-MM-DDThh:mm:ss). This
// method ignores any additional information like milliseconds or timezones.
func IsIsoString(date string) bool {
	parts := []rune(date)

	return len(parts) >= 19 &&
		unicode.IsNumber(parts[0]) &&
		unicode.IsNumber(parts[1]) &&
		unicode.IsNumber(parts[2]) &&
		unicode.IsNumber(parts[3]) &&
		parts[4] == '-' &&
		unicode.IsNumber(parts[5]) &&
		unicode.IsNumber(parts[6]) &&
		parts[7] == '-' &&
		unicode.IsNumber(parts[8]) &&
		unicode.IsNumber(parts[9]) &&
		parts[10] == 'T' &&
		unicode.IsNumber(parts[11]) &&
		unicode.IsNumber(parts[12]) &&
		parts[13] == ':' &&
		unicode.IsNumber(parts[14]) &&
		unicode.IsNumber(parts[15]) &&
		parts[16] == ':' &&
		unicode.IsNumber(parts[17]) &&
		unicode.IsNumber(parts[18])
}

func IsMonth(match string) bool {
	return ArrayBinaryMatchString(match, DATE_MONTHS)
}

func IsTime(match string) bool {
	// 00:00:00.000
	check := []rune(match)
	size := len(check)

	if size == 8 {
		return unicode.IsNumber(check[0]) &&
			unicode.IsNumber(check[1]) &&
			check[2] == ':' &&
			unicode.IsNumber(check[3]) &&
			unicode.IsNumber(check[4]) &&
			check[5] == ':' &&
			unicode.IsNumber(check[6]) &&
			unicode.IsNumber(check[7])
	} else if size == 12 {
		return unicode.IsNumber(check[0]) &&
			unicode.IsNumber(check[1]) &&
			check[2] == ':' &&
			unicode.IsNumber(check[3]) &&
			unicode.IsNumber(check[4]) &&
			check[5] == ':' &&
			unicode.IsNumber(check[6]) &&
			unicode.IsNumber(check[7]) &&
			check[8] == '.' &&
			unicode.IsNumber(check[9]) &&
			unicode.IsNumber(check[10]) &&
			unicode.IsNumber(check[11])
	} else {
		return false
	}
}
